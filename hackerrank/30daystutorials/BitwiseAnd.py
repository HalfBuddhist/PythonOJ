#!/usr/bin/env python
# coding=utf-8
"""
应该想到k同样位于集合S中，那么k-1的值不是不可能为逻辑与后得到的值!!!!
况且你也想到了相邻的值逻辑与后的越大，后面相相邻的值的一般情况下大于前面的（有进位的情况除外）
取得k-1的值，比如说k-1的末位为0，那么与k与后的值就为k-1.
O(1)
"""

for _ in xrange(int(raw_input())):
    n, k = map(int, raw_input().split())
    a = k - 1  # k-1为有可能的最大的逻辑与的值, 这里我们可令a = A
    b = ~a & -~a  # 取-a的取低有效位， 即取a的最低无效位对应的置1值。
    # 由于b为最低无效位的置1值，则a|b = a+b, 且 a&(a|b) = a = k-1
    # a|b 即为B的值，这样可在没有进位的情况下，获得逻辑与为a的结果
    # 为值选取b-最低无效位的置值，则是因为这是使保持与后结果为其自身的最小值，这是显然的。
    # 这样B才最小，因为B必须要小于n.
    if a | b > n:
        # 这种情况下k-1是不可得到了，因为b是使与后结果不变的最小值
        # 因为B过大，是因为b过大，则b肯定不为1，因为否则B=a|b=a+b=k<=n
        # 也就是说a的个位是有效位，A = a-1 = k-2是有可能的最大值了，a-1则使
        # 最低无效位置1值 b=1, 此时B=(a-1)|b = (a-1)+b = k-1 < N, 有效，A = a-1 = k-2 < N,
        # 这样可以保证（k-2）这个可能的最大值可以得到, 如此最大值为k-2 = a-1
        print a - 1
    else:
        # 此时我们可以找到A, B使得A&B=a=k-1，使得有可能的最大值可以获得，即最大值为k-1=a
        print a