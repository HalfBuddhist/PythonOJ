#!/usr/bin/env python
# coding=utf-8
"""
方法一：贪心 + 动态规划
思路与算法：复杂问题 -> 基本算法（贪心）+ 基本（DP）

本题为「53. 最大子数组和」的进阶版，建议读者先完成该题之后，再尝试解决本题。

求解普通数组的最大子数组和是求解环形数组的最大子数组和问题的子集。设数组长度为 n，
下标从0 开始，在环形情况中，答案可能包括以下两种情况：

1. 构成最大子数组和的子数组为 nums[i:j]，包括 nums[i] 到 nums[j−1] 共 j−i 个元素，
    其中 0≤i<j≤n。
2. 构成最大子数组和的子数组为 nums[0:i] 和 nums[j:n]，其中 0<i<j<n。

第一种情况的求解方法与求解普通数组的最大子数组和方法完全相同，读者可以参考 53 号题目的题解：最大子序和。

第二种情况中，答案可以分为两部分，nums[0:i] 为数组的某一前缀，nums[j:n] 为数组的某一后缀。
求解时，我们可以枚举 j，固定 sum(nums[j:n]) 的值，
然后找到右端点坐标范围在 [0,j−1] 的最大前缀和，将它们相加更新答案。

右端点坐标范围在 [0,i] 的最大前缀和可以用 leftMax[i] 表示，递推方程为：
leftMax[i]=max(leftMax[i−1],sum(nums[0:i+1])

至此，我们可以使用以上方法求解出环形数组的最大子数组和。特别需要注意的是，本题要求子数组不能为空，我们需要在代码中做出相应的调整。

关键点：
1，分开考虑
2，动态规划

思考路径：
复杂问题分开情况讨论，2段的情况如果能分别求到最大和，就有戏，
发现会重叠，只能分开，分别计算固定位置下的最值，这样就可以了，
贪心的话超复杂度，发现 DP 可以直接递推，至少得解。
后面发现求1端的最值就可以了，另一端的最佳在枚举的时候就包含了，而且肯定优于或者等价于当前的子串。
"""

import sys, time
from queue import PriorityQueue
from collections import deque
from typing import List

class Solution:
    def maxSubarraySumCircular(self, nums: List[int]) -> int:
        n = len(nums)
        leftMax = [0] * n
        # 对坐标为 0 处的元素单独处理，避免考虑子数组为空的情况
        leftMax[0], leftSum = nums[0], nums[0] 
        pre, res = nums[0], nums[0]
        for i in range(1, n):
            pre = max(pre + nums[i], nums[i])
            res = max(res, pre)
            leftSum += nums[i]
            leftMax[i] = max(leftMax[i - 1], leftSum)
        # 从右到左枚举后缀，固定后缀，选择最大前缀
        rightSum = 0
        for i in range(n - 1, 0, -1):
            rightSum += nums[i]
            res = max(res, rightSum + leftMax[i - 1])
        return res


if __name__ == '__main__':
    begin_clock = time.time()
    sys.stdin = open('in.txt', 'r')
    # sys.stdout = open('../out.txt', 'w')
    # presolve
    # input
    nums = [52,183,124,154,-170,-191,-240,107,-178,171,75,186,-125,61,-298,284,21,-73,-294,253,146,248,-248,127,26,289,118,-22,-300,26,-116,-113,-44,29,252,-278,47,254,-106,246,-275,42,257,15,96,-298,-69,-104,-239,-95,-4,76,-202,156,-14,-178,188,-84,78,-195,-125,28,109,125,-25,-53,58,287,55,-296,198,281,53,-160,146,298,25,-41,-3,27,-242,169,287,-281,19,91,213,115,211,-218,124,-25,-272,278,296,-177,-166,-192,97,-49,-25,168,-81,6,-94,267,293,146,-1,-258,256,283,-156,197,28,78,267,-151,-230,-66,100,-94,-66,-123,121,-214,-182,187,65,-186,215,273,243,-99,-76,178,59,190,279,300,217,67,-117,170,163,153,-37,-147,-251,296,-176,117,68,258,-159,-300,-36,-91,-60,195,-293,-116,208,175,-100,-97,188,79,-270,80,100,211,112,264,-217,-142,5,105,171,-264,-247,138,275,227,-86,30,-219,153,10,-66,267,22,-56,-70,-234,-66,89,182,110,-146,162,-48,-201,-240,-225,-15,-275,129,-117,28,150,84,-264,249,-85,70,-140,-259,26,162,5,-203,143,184,101,140,207,131,177,274,-178,-79,14,-36,104,52,31,257,273,-52,74,276,104,-133,-255,188,-252,229,200,-74,-39,-250,142,-201,-196,-43,-40,255,-149,-299,-197,-175,-96,-155,-196,-24,12,79,71,-144,-59,-120,227,-256,-163,-297,116,286,-283,-31,-221,-41,121,-170,160,205,8,88,25,-272,-107,292,-180,299,94,-97,-81,-134,37,238]
    print(Solution().maxSubarraySumCircular(nums))


    # resolve   
    # output
    print(time.time() - begin_clock, 'seconds')
